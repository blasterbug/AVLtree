\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{ifpdf}
\usepackage{hyperref}
\usepackage{amsmath}

\title{\textit{Quel bazar!}}
\author{Thomas \textsc{Minier} \and Benjamin \textsc{Sientzoff}}
\date{\today}
\ifpdf
\hypersetup{
    pdfauthor={Thomas Minier, Benjamin Sientzoff},
    pdftitle={Quel bazar!},
}
\fi
\begin{document}
	% page de garde avec sommaire
	\maketitle
	\vspace{5cm}
	\tableofcontents
	\newpage % passer à la page suivante
	
	\section*{Introduction}

		\paragraph{}{
		Dans le cadre du module d'algorithmique et structure de données 3, il nous a été demandé de 
		proposer un algorithme pour résoudre un problème précis. Il s'agit, en partant d'un ensemble 
		de pages provenant d'un livre, de les regrouper en chapitres. pour cela, nous utiliserons 
		un dictionnaire de mots et le critère suivant : si deux pages ont en commun au moins les 
		$k$ mêmes mots du dictionnaire, alors elles appartiennent au même chapitre. \newline
		Nous devons également identifier, pour chaque chapitre, les mots propre à ce dernier.
		}
		
		\paragraph{}{
		Pour résoudre ce problème, nous avons donc mis en place un programme Java articulé autour 
		d'un algorithme principal utilisant plusieurs structures de données. Ces dernières ont été 
		choisies pour rendre la résolution du problème aussi efficace que possible. Nous avons 
		donc cherché à minimiser la complexité de l'algorithme principal par l'utilisation de 
		structures efficaces.
		}
		
		\paragraph{}{
		Pour compiler et utiliser notre programme procédez comme suit.
		\begin{verbatim}
			$ cd AVLTree
			$ make
			$ java -jar Bazar.jar <k> <dictionnaire> <page_1> <page_2> ... <page_n>
		\end{verbatim}
		}
		
		
	\section{Structures utilisées}
	
		\subsection{Arbre AVL}
		
		\paragraph{}{
		Il s'agit d'une structure d'arbre binaire avec équilibrage mise au point par 
		Adelson-Velsky et Landis. Cet AVL est là pour stocker les mots du dictionnaire et, 
		par page, les mots du dictionnaire présent dans la page. Nous avons implémenté la 
		structure vue en cours, avec des méthodes d'ajout et d'équilibrage par rotations. 
		Nous avons aussi ajouté des méthodes non vues en cours, qui sont détaillées çi dessous :
		}
		
		\begin{itemize}
			\item \verb|contains( elt T ) : booleen| est une fonction qui renvoie Vrai si le 
			l'élément de type T passé en paramètre est présent dans l'arbre. L'algorithme de
			cette fonction est à la figure \ref{algo_contains}.
			\begin{figure}
	    	    \begin{verbatim}
	    	    fonction contient
	    	        entrée : elt element
	    	                 noeud AVL
	    	        sortie : Vrai si elt appartient à l'AVL
	    	                 Faux sinon
	    	    debut
	    	        si (non estFeuille(noeud)) alors
	    	            si (noeud.etq = elt alors
	    	                retourner Vrai;
	    	            sinon
	    	                retourner noeud.fils_gauche.contains(elt) 
	    	                           OU noeud.fils_droit.contains(elt);
	    	        sinon si (noeud.etq = elt) alors
	    	            retourner Vrai;
	    	        sinon
	    	            retourner Faux;
	    	    fin
	    	    \end{verbatim}
	    	    \caption{Algorithme de la fonction \textit{contains} de AVL \label{algo_contains} }
	    	\end{figure}
			\item \verb|toString() : chaîne| est une fonction qui renvoie une représentation 
			sous forme de chaîne de caractères de l'arbre. L'algorithme de cette fonction est 
			à la figure \ref{algo_toString_avl}.
			
			\begin{figure}
	    	    \begin{verbatim}
	    	    fonction toString
	    	        entrée : noeud AVL
	    	        sortie : une chaîne de caractère
	    	    debut
	    	        si (estFeuille(noeud)) alors
	    	            retourner noeud.etq;
	    	        sinon
	    	            retourner noeud.fils_gauche.toString() 
	    	                        + noeud.etq 
	    	                        + noeud.fils_droit.toString();
	    	        finsi
	    	    fin
	    	    \end{verbatim}
	    	    \caption{Algorithme de la fonction \textit{toString} de AVL \label{algo_toString_avl} }
	    	\end{figure}
	    	
			\item \verb|nbCommuns( arbre : AVL ) : entier| est une fonction qui renvoie
			le nombre d'éléments en communs entre l'arbre courant et l'arbre passé en 
			paramètre. L'algorithme de cette fonction est à la figure \ref{algo_nbCommuns}.
			
			\begin{figure}
	    	    \begin{verbatim}
	    	    fonction nbCommuns
	    	        entrée : arbre AVL
	    	        sortie : entier
	    	        variables : i entier
	    	    debut
	    	        si (arbre.contains(noeud.etq)) alors
	    	            i := 1
	    	        sinon
	    	            i := 0
	    	        finsi
	    	        retourner  i + noeud.fils_gauche.nbCommuns(arbre) 
	    	                     + noeud.fils_droit.nbCommuns(arbre)
	    	    fin
	    	    \end{verbatim}
	    	    \caption{Algorithme de la fonction \textit{nbCommuns} de AVL \label{algo_nbCommuns} }
	    	 \end{figure}
	    	 
		\end{itemize}
		
		\subsection{Classe-Union}
		    \paragraph{}{
		    Une classe-union est une structure de données permettant stocker des ensembles 
		    disjoints d'éléments. ces sous-ensembles sont appelés classes. Chaque classe a
		    un représentant. Dans notre cas, les classes sont des arbres, leur représentant
		    est alors la racine de cet arbre. L'avantage d'utiliser une telle structure est
		    de pouvoir faire l'union des sous-ensembles simplement. Dans notre programme, 
		    les arbres des classes sont implémentées dans un tableau.
		    }
		    \begin{itemize}
			    \item \verb|find( el T ) : T| est la première fonction pertinente d'une classe-union. Cette fonction permet de trouver 
	    	le représentant d'une classe. Elle prend en paramètre un élément $t$ et retourne le représentant de la classe à
	    	laquelle appartient $t$.
	    	L'algorithme de cette fonction est à la figure \ref{algo_find}. Pour des questions de d'optimisation, cette fonction
	    	compresse les chemins de l'arbre, on obtient alors une complexité amortie en $\Theta(1)$.
	    	
	    	\begin{figure}
	    	    \begin{verbatim}
	    	    fonction trouver
	    	        entrées : x element
	    	        sorties : element
	    	    debut
	    	        si ( x.parent != x ) alors
	    	            x.parent := trouver( x )
	    	        fin pour
	    	        retourner x.parent
	    	    fin
	    	    \end{verbatim}
	    	\caption{Algorithme de la fonction trouver de classe-union \label{algo_find}}
	    	\end{figure}
	    	
	    	\item \verb|union( el1 : T, el2 : T)| permet de faire l'union de deux classes. Son algorithme est disponible à la 
	        figure \ref{algo_union}. Une telle fonction prend en paramètre deux éléments et va unir leurs deux classes.
	        Sa complexité est de l'ordre de $\Theta(1)$. En effet, la fonction \textit{trouver} a une complexité en $\Theta(1)$,
	        puis cette fonction ne fait que des affections.

	    	\begin{figure}
	    	    \begin{verbatim}
	    	    procédure unir
	    	        entrées : x, y element
	    	        variables : p_x, p_y element
	    	    debut
	    	        p_x := trouver( x )
	    	        p_y := trouver( y )
	    	        p_y.parent := p_x;
	    	    fin
	    	    \end{verbatim}
	    	\caption{Algorithme de la fonction unir de classe-union \label{algo_union}}
	    	\end{figure}
	    	\end{itemize}
		
		\subsection{Paire}
	    	\paragraph{}{
	    	Cette structure représente une paire d'éléments, appelés 
	    	respectivement partie gauche et partie droite. Elle dispose de quelques 
	    	fonctions et procédures, que nous détaillons ci-dessous.
	    	}
	    	
	    	\begin{itemize}
	    	
	    		\item Des \textit{getters}, \verb|getLeft(): T| et \verb|getRight(): T|, 
	    		et des \textit{setters}, \verb|setLeft(T elt)| et \verb|setRight(T elt)|, 
	    		pour pouvoir accéder et modifier les éléments de la paire.
	    		
	    		\item \verb|toString() : chaîne| renvoie une représentation sous forme 
	    		d'une chaîne de caractères de la paire. Elle concatène le partie gauche 
	    		et la partie droite de la paire et retourne la chaîne ainsi formée.
	    		
	    	\end{itemize}
		
		%\subsection{Scanner de fichiers}
	    	%\paragraph{}{paragraphe sans titre}
		
	\section{Résolution du problème}
	
		\paragraph{Quel bazar}{
		Le problème que nous devons résoudre est le suivant : reformer les chapitres 
		d'un livre en regroupant les pages de ce dernier si ils ont au moins $k$ même
		mots du dictionnaire en commun. La difficulté ici est d'identifier les mots 
		qui appartiennent au dictionnaire en lisant les pages puis de regrouper ces
		pages suivant les $k$ mots en commun.
		}
		
		\subparagraph{}{
		Concernant l'identification des mots uniques aux pages, nous en sommes pas
		préoccupés, par manque de temps.
		}
	
	
		\subsection{Notre approche}
		
			\paragraph{}{
			Évidemment, une approche basique du problème consisterais à produire un algorithme (glouton) avec une complexité
			exorbitante. Mais soyons plus intelligent et penchons nous sur des structures efficaces, comme celles présentées
			dans la première partie de ce rapport. Tout d'abord pour les recherches des mots, en utilisant un arbre et non
			un tableau, ou une autre structure de données linéaire de type file ou liste chaînée, on passe d'une complexité
			en $\Theta(n)$ à $\Theta(\log(n))$, $n$ étant le nombre de mots dans le dictionnaire.
			}
			\paragraph{}{
			Ensuite, pour les pages, au lieu de garder en mémoire l'intégralité de ces dernières, stockons 
			uniquement les mots qu'elles ont en commun avec le dictionnaire. Après la même question revient, tableau
			ou arbre ? Arbre ! Potentiellement, comme pour le dictionnaire, on va effectuer des recherches sur les mots des pages.
			Et on peut estimer le nombre de telles recherches de l'ordre de $k \times n^{2}$. \\
			En effet, on va obligatoirement chercher les $k$ mots dans le dictionnaire. En suite pour ces $k$ mots, on va comparer
			les pages obligatoirement deux par deux. Donc avec $n$, le nombre de pages, on obtient $n^{2}$ comparaisons.
			}

		\subsection{Algorithme}
			\paragraph{}{
			L'algorithme à la figure \ref{algo_main} correspond à l'algorithme qui résout le problème
			de la réunion des pages par chapitre. On peut y détacher les grandes étapes suivantes :
			\begin{enumerate}
				\item Lecture du dictionnaire, stockage dans un AVL.
				\item Pour chaque page, les parcourir rt identifier les mots qu'elle
				a en commun avec le dictionnaire, placer ses mots dans un AVL.
				\item On place toutes les pages dans une classe-union.
				\item Pour chaque page, on test combien de mots elle a en commun avec les autres.
				Si elle en a au moins $k$, on réuni les classes des deux pages.
				\item Enfin, on affiche la solution
			\end{enumerate} 
		 	}
		 	\paragraph{Complexité}{
		 	Considérons que le dictionnaire est composé de $k$ mots. Il y a $n$ pages composées de
		 	$q_{i}$ mots, $i$ étant l'identifiant de la page. \newline
		 	La lecture des fichiers en entrée du programme ce fait en un temps linéaire.
		 	}
   			\begin{figure}
	    	    \begin{verbatim}
	    	    Algorithme principal
	    	        entrées : k entier
	    	                  dico ensemble de mots
	    	                  pages ensemble d'ensembles de mots
	    	        variables : k entier
	    	                    dictionnaire AVL de chaîne
	    	                    collection Vector de Pair(chaîne, AVL de chaîne)
	    	                    classeUnion ClasseUnion de Pair(chaîne, AVL de chaîne)
	    	                    pairA, pairB Pair(chaîne, AVL de chaîne)
	    	    debut
	    	        dictionnaire := AVL vide;
	    	        collection := Vector de Pair(chaîne, AVL de chaîne) vide;
	    	        
	    	        pour chaque mot dans page faire
	    	            dictionnaire.ajouter(mot);
	    	        finpour
	    	            
	    	        pour chaque page dans pages faire
	    	            pair := Pair(chaîne, AVL de chaîne) vide;
	    	            pair.element_gauche := premier_mot(page);
	    	            pair.element_droit := AVL vide;
	    	            
	    	            pour chaque mot dans page faire
	    	                si (dictionnaire.contient(mot)) faire
	    	                    pair.element_doit.ajouter(mot);
	    	                finsi
	    	            finpour
	    	            
	    	            collection.ajouter(pair);
	    	        finpour
	    	        
	    	        classeUnion := ClasseUnion(collection);
	    	        
	    	        pour i de 0 à taille(collection) - 1 faire
	    	          pairA := collection[i]
	    	            
	    	          pour j de 0 à taille(collection) - 1 faire
	    	            pairB := collection[j]
	    	            si ( (i != j)
	    	               ET (classeUnion.trouver(pairA) != classeUnion.trouver(pairB))
	    	               ET (pairA.element_droit.nbCommuns(pairB.element_droit) >= k))
	    	                classeUnion.union(pairA, pairB);
	    	            finsi
	    	          finpour
	    	        finpour
	    	        afficher(classeUnion);
	    	    fin
	    	    \end{verbatim}
   	    	\caption{Algorithme principal \label{algo_main}}
   	    	\end{figure}
			
	\section*{Conclusion}
		\paragraph{}{
		Pour conclure, notre algorithme nous a permis de fournir une solution plutôt efficace, tout de
		même de l'ordre de $\Theta(X)$.
		}
		
\end{document}
