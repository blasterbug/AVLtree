\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{ifpdf}
\usepackage{hyperref}
\usepackage{amsmath}

\title{\textit{Quel bazar!}}
\author{Thomas \textsc{Minier} \and Benjamin \textsc{Sientzoff}}
\date{\today}
\ifpdf
\hypersetup{
    pdfauthor={Thomas Minier, Benjamin Sientzoff},
    pdftitle={Quel bazar!},
}
\fi
\begin{document}
	% page de garde avec sommaire
	\maketitle
	\vspace{5cm}
	\tableofcontents
	\newpage % passer à la page suivante
	
	\section*{Introduction}

		\paragraph{}{
		Dans le cadre du module d'Algorithmique et structure de données 3, il nous a été demandé de proposer un algorithme pour résoudre un problème précis. Il s'agit, en partant d'un ensemble de pages provenant d'un livre, de les regrouper en chapitres. pour cela, nous utiliserons un dictionnaire de mots et le critère suivant : si deux pages ont en commun au moins les $k$ mêmes mots du dictionnaire, alors elles appartiennent au même chapitre.
		}
		
		\paragraph{}{
		Pour résoudre ce problème, nous avons donc mis en place un programme Java articulé autour d'un algorithme principal et de plusieurs structures de données. Ces dernières ont été choisies pour rendre la résolution du problème aussi efficace que possible. Nous avons donc cherché à minimiser la complexité de l'algorithme principal.
		}
		
		\paragraph{}{
		Pour compiler et utiliser notre programme procédez comme suit.
		\begin{verbatim}
			$ cd AVLTree
			$ ant
			$ cd bin
			$ java bazar <k> <fichier_dictionnaire> <page_1> <page_2> ... <page_n>
		\end{verbatim}
		}
		
		\subparagraph{}{
		Si le programme \textit{Ant} n'est pas installé sur votre ordinateur il est soit possible de compiler le programme en la remplaçant par \textit{make} soit avec la commande suivante : \verb|javac ....| .
		}
		
		
	\section{Structures utilisées}
	
		\subsection{Arbre AVL}
		
		\paragraph{}{Il s'agit de la structure d'arbre binaire avec équilibrage, mise au point par Adelson-Velsky et Landis. Cet AVL est là pour stocker les mots du dictionnaire et, par page, les mots du dictionnaire présent dans la page. Nous avons implémenté la structure vue en cours, avec des méthodes d'ajout et d'équilibrage par rotations. Nous avons aussi ajouté des méthodes non vues en cours, qui sont détaillées çi dessous :}
		
		\begin{itemize}
			\item \verb|contains(T elt) : booleen| Cette fonction renvoie Vrai si le l'élément de type T passé en paramètre est présent dans l'arbre. L'algorithme de cette fonction est à la figure \ref{algo_contains}.
			\begin{figure}
	    	    \begin{verbatim}
	    	    fonction contains
	    	        entrée : elt : T
	    	        sortie : Vrai si elt appartient à l'AVL
	    	                 Faux sinon
	    	    debut
	    	        si (non estFeuille(noeud)) alors
	    	            si (noeud.etq = elt alors
	    	                retourner Vrai;
	    	            sinon
	    	                retourner noeud.fils_gauche.contains(elt) 
	    	                           OU noeud.fils_droit.contains(elt);
	    	        sinon si (noeud.etq = elt) alors
	    	            retourner Vrai;
	    	        sinon
	    	            retourner Faux;
	    	    fin
	    	    \end{verbatim}
	    	    \caption{Algorithme de la fonction \textit{contains} de AVL \label{algo_contains} }
	    	\end{figure}
			\item \verb|toString(): chaîne| Cette fonction renvoie une représentation sous forme de chaîne de caractères de l'arbre. L'algorithme de cette fonction est à la figure \ref{algo_toString_avl}.
			
			\begin{figure}
	    	    \begin{verbatim}
	    	    fonction toString
	    	        entrée : aucune
	    	        sortie : une chaîne de caractère
	    	    debut
	    	        si (estFeuille(noeud)) alors
	    	            retourner noeud.etq;
	    	        sinon
	    	            retourner noeud.fils_gauche.toString() 
	    	                        + noeud.etq 
	    	                        + noeud.fils_droit.toString();
	    	        finsi
	    	    fin
	    	    \end{verbatim}
	    	    \caption{Algorithme de la fonction \textit{toString} de AVL \label{algo_toString_avl} }
	    	\end{figure}
	    	
			\item \verb|nbCommuns(AVL arbre) : entier| Cette  fonction renvoie le nombre d'éléments en communs entre l'arbre courant et l'arbre passé en paramètre. L'algorithme de cette fonction est à la figure \ref{algo_nbCommuns}.
			
			\begin{figure}
	    	    \begin{verbatim}
	    	    fonction nbCommuns
	    	        entrée : arbre : AVL
	    	        sortie : un entier
	    	    debut
	    	        entier i;
	    	        si (arbre.contains(noeud.etq)) alors
	    	            i := 1;
	    	        sinon
	    	            i := 0;
	    	        finsi
	    	        retourner  i + noeud.fils_gauche.nbCommuns(arbre) 
	    	                     + noeud.fils_droit.nbCommuns(arbre);
	    	    fin
	    	    \end{verbatim}
	    	    \caption{Algorithme de la fonction \textit{nbCommuns} de AVL \label{algo_nbCommuns} }
	    	 \end{figure}
	    	 
		\end{itemize}
		
		\subsection{Classe-Union}
		    \paragraph{}{
		    Une classe-union est une structure de données permettant stocker des ensembles disjoints d'éléments. ces sous-ensembles sont 
		    appelés classes. Chaque classe a un représentant. Dans notre cas, les classes sont des arbres, leur représentant est alors
		    la racine de cet arbre. L'avantage d'utiliser une telle structure est de pouvoir faire l'union des
		    sous-ensembles simplement. Dans notre programme, les classes sont implémentées dans un tableau.
		    }
		    \begin{itemize}
			    \item \verb|find( el : T) : T| est la première fonction pertinente d'une classe-union. Cette fonction permet de trouver 
	    	le représentant d'une classe. Elle prend en paramètre un élément $t$ et retourne le représentant de la classe à
	    	laquelle appartient $t$.
	    	L'algorithme de cette fonction est à la figure \ref{algo_find}. Pour des questions de d'optimisation, cette fonction
	    	compresse les chemins de l'arbre.
	    	
	    	\begin{figure}
	    	    \begin{verbatim}
	    	    fonction trouver
	    	        entrées : x element
	    	        sorties : element
	    	    debut
	    	        si x.parent != x
	    	            x.parent := trouver( x )
	    	        fin pour
	    	        retourner x.parent
	    	    fin
	    	    \end{verbatim}
	    	\caption{Algorithme de la fonction trouver de classe-union \label{algo_find}}
	    	\end{figure}
	    	
	    	\item \verb|union( el1 : T, el2 : T)| permet de faire l'union de deux classes. Son algorithme est disponible à la 
	        figure \ref{algo_union}. Une telle fonction prend en paramètre deux éléments et va unir leurs deux classes.

	    	\begin{figure}
	    	    \begin{verbatim}
	    	    fonction unir
	    	        entrées : x, y elements
	    	        variables : p_x, p_y element
	    	    debut
	    	        p_x := trouver( x ) 
	    	        p_y := trouver( y )
	    	        p_y.parent := p_x
	    	    fin
	    	    \end{verbatim}
	    	\caption{Algorithme de la fonction unir de classe-union \label{algo_union}}
	    	\end{figure}
	    	\end{itemize}
		
		\subsection{Paire}
	    	\paragraph{}{cette structure représente une paire d'éléments, appelés respectivement partie gauche et partie droite. Elle dispose de quelques fonctions et procédures, que nous détaillons ci-dessous.}
	    	
	    	\begin{itemize}
	    	
	    		\item Des \textit{getters}, \verb|getLeft(): T| et \verb|getRight(): T|, et des \textit{setters}, \verb|setLeft(T elt)| et \verb|setRight(T elt)|, pour pouvoir accéder et modifier les éléments de la paire.
	    		
	    		\item \verb|toString() : chaîne| Cette fonction renvoie une représentation sous forme d'une chaîne de caractères de la paire. Elle concatène le partie gauche et la partie droite de la paire et retourne la chaîne ainsi formée.
	    		
	    	\end{itemize}
		
		%\subsection{Scanner de fichiers}
	    	%\paragraph{}{paragraphe sans titre}
		
	\section{Résolution du problème}
	
		\paragraph{Quel bazar}{
		Le problème que nous devons résoudre est le suivant : reformer les chapitres d'un livre en regroupant les pages 
		de ce dernier si ils ont au moins $k$ même mots du dictionnaire en commun. La difficulté ici est d'identifier
		les mots qui appartiennent au dictionnaire en lisant les pages puis de regrouper ces pages suivant les $k$ mots en
		commun.
		}
	
	
		\subsection{Notre approche}
		
			\paragraph{}{
			Évidemment, une approche basique du problème consisterai à produire un algorithme (glouton) avec une complexité
			exorbitante. Mais soyons plus intelligent et penchons nous sur des structures efficaces, comme celles présentées
			dans la première partie de ce rapport. Tout d'abord pour les recherches des mots, en utilisant un arbre et non
			un tableau ou une autre structure de données linéaire de type file ou liste chaînée, on passer d'une complexité
			en $\Theta(n)$ à $\Theta(\log(n))$, $n$ étant le nombre de mots dans le dictionnaire.
			}
			\paragraph{}{
			Ensuite, pour les pages, au lieu de garder en mémoire l'intégralité de ces dernières, stockons les mots qu'elles
			ont en commun avec le dictionnaire. Les autres mots ne servent à rien. Après la même question revient, tableau
			ou arbre ? Arbre! Potentiellement, comme pour le dictionnaire, on va effectuer des recherches sur les mots des pages.
			Et on peut estimer le nombre de telles recherches de l'ordre des $k \times n^{2}$. \\
			En effet, on va obligatoirement chercher les $k$ mots
			}

		\subsection{Algorithme}
			\paragraph{}{paragraphe sans titre}	
			
	\section*{Conclusion}
		\paragraph{}{je conclu}
		
\end{document}
